package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"math"
	"os"
	"reflect"
	"regexp"
	"strings"

	"github.com/golang/lint"
)

type arrayFlags []string

func (i *arrayFlags) String() string {
	return fmt.Sprintf("%v", *i)
}

func (i *arrayFlags) Set(value string) error {
	*i = append(*i, value)
	return nil
}

func loadJSONFromFile(jsonFilePath string) (interface{}, error) {
	file, err := os.Open(jsonFilePath)
	var obj interface{}

	if err != nil {
		return err, nil
	}

	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&obj)

	return obj, err
}

func isValidJSON(jsonBlob interface{}) bool {
	t := reflect.TypeOf(jsonBlob)

	return (t.Kind() == reflect.Map && t.Key().Kind() == reflect.String)
}

func toStruct(jsonBlob interface{}, structName string) (string, error) {
	if !isValidJSON(jsonBlob) {
		return "", errors.New("json2struct can only handle map[string]interface{} json input files")
	}

	jsonMap := jsonBlob.(map[string]interface{})
	structSrc := fmt.Sprintf("// %v autogenerated\n", structName)
	structSrc += fmt.Sprintf("type %v struct {\n", structName)

	for k, v := range jsonMap {
		structSrc += fmt.Sprintf("\t%v %v `json:\"%v\"`\n", strings.Title(k), reflect.TypeOf(v), k)
	}

	structSrc += "}\n"

	return structSrc, nil
}

func fixLinterProblems(srcBytes []byte, problems []lint.Problem) []byte {
	src := string(srcBytes)

	for _, problem := range problems {
		// Try to fix naming problem
		if problem.Category == "naming" {

			regexStr := "struct field (?P<fieldName>.+?) should be (?P<replacementName>.+)"
			r := regexp.MustCompile(regexStr)
			m := r.FindStringSubmatch(problem.Text)

			if len(m) > 0 {
				newLineText := strings.Replace(problem.LineText, m[1], m[2], 1)
				src = strings.Replace(src, problem.LineText, newLineText, 1)
			}
		}
	}

	return []byte(src)
}

// json2struct converts a json file to a struct src file, you can specify multiple source files and combine them in one
// output file
func json2struct(jsonFilePaths []string, structNames []string, packageName string, needPackageComment bool, outputFilePath string) error {
	n := int(math.Max(float64(len(jsonFilePaths)), float64(len(structNames))))

	// Generate package header
	src := "// Code generated by json2struct DO NOT EDIT\n\n"

	if needPackageComment {
		src += fmt.Sprintf("// Package %v autogenerated\n", packageName)
	}

	src += fmt.Sprintf("package %v\n\n", packageName)

	// For each json file create a struct src
	for i := 0; i < n; i++ {
		jsonFilePath := jsonFilePaths[i]
		structName := structNames[i]

		genericMap, err := loadJSONFromFile(jsonFilePath)
		if err != nil {
			return err
		}

		srcStr, err := toStruct(genericMap, structName)
		if err != nil {
			return err
		}

		src += srcStr + "\n"
	}

	// Format code properly
	srcBytes, err := format.Source([]byte(src))
	if err != nil {
		return err
	}

	// Pass through linter, fix linter problems if needed
	linter := &lint.Linter{}
	problems, err := linter.Lint(outputFilePath, srcBytes)
	if err != nil {
		return err
	}

	if len(problems) > 0 {
		srcBytes = fixLinterProblems(srcBytes, problems)
	}

	// Write to file
	return ioutil.WriteFile(outputFilePath, srcBytes, 0644)
}

func main() {
	var inputFiles arrayFlags
	var structNames arrayFlags
	var packageName string
	var needPackageComment bool
	var outputFilePath string

	flag.StringVar(&packageName, "package", "", "Package name")
	flag.BoolVar(&needPackageComment, "comment", false, "Add autogenerated package comment to silence linter warning")
	flag.StringVar(&outputFilePath, "output", "", "Output file path")
	flag.Var(&inputFiles, "input", "One or more input JSON file paths")
	flag.Var(&structNames, "struct", "One or more of struct name pairs")
	flag.Parse()

	if packageName == "" {
		log.Fatal("json2struct needs a package name")
	}

	if outputFilePath == "" {
		log.Fatal("json2struct needs an output file path")
	}

	err := json2struct(inputFiles, structNames, packageName, needPackageComment, outputFilePath)
	if err != nil {
		log.Fatalf("fatal error: %v", err)
	}
}
